<!DOCTYPE html>
<html>
<head>
<style>
#info {
  position: absolute;
  top: 0px;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00
}

body {
  overflow: hidden;
}

</style>
</head>

<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/104/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js">
</script>
<div id="info">minimal MODULE three.js</div>
 
<script>
import * as THREE from "https://threejs.org/build/three.module.js";
import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";

var camera, scene, renderer;
var light, light2;
var angle = 0;
var puck, puck2;
var balls = [];
var attach = false;
const R = 4;

class Ball{
	constructor(pos, vel, mesh){
    this.pos = pos;
    this.vel = vel;
    this.force = new THREE.Vector3(0,0,0);
    this.mesh = mesh;
    scene.add (this.mesh);
    mesh.material.color = new THREE.Color().setHSL (Math.random(), 0.5, .7);
        
  	/*puckColor = new THREE.MeshBasicMaterial();
    puckColor.color = new THREE.Color().setHSL (173/360,.98,.44);
  	puck = new THREE.Mesh (new THREE.CylinderGeometry(10,10,4,20), puckColor);*/
  }
  update(dt) {
  	this.vel.add (this.force.clone().multiplyScalar (dt));
  	this.pos.add (this.vel.clone().multiplyScalar (dt));
  
    // wall-collision
  if (this.pos.z < -70+R) {
  	 this.vel.z = - this.vel.z;
     
     this.pos.z = -70+R;
  }
   if (this.pos.z > 70+R) {
  	 this.vel.z = - this.vel.z;
     
     this.pos.z = 70+R;
  }
  if (this.pos.x > 70-R) {
  	 this.vel.x = - this.vel.x;
     
     this.pos.x = 70-R;
  }
 if (this.pos.x < -70+R) {
  	 this.vel.x = - this.vel.x;
     
     this.pos.x = -70+R;
  }
  
  
	this.mesh.position.copy (this.pos);
   
   }
}
function buildBallMesh (mycolor) {


   
  let ballMesh = new THREE.Mesh (new THREE.CylinderGeometry(10,10,4,20), new THREE.MeshBasicMaterial());
  ballMesh.material.color = mycolor;
  return ballMesh;
}

init();
animate();



function init() {

  scene = new THREE.Scene();

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);
  document.body.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.set (0,400,0);
  let controls = new OrbitControls(camera, renderer.domElement);
	
  ////////////////////////////////////////////////////////////////
  
  let ballMesh = buildBallMesh (new THREE.Color().setHSL (Math.random(), .9, .4));
  
  let ball = new Ball (new THREE.Vector3(20,5,5), new THREE.Vector3(-4,0,5), ballMesh);
	balls.push (ball);

  ballMesh = buildBallMesh (new THREE.Color().setHSL (Math.random(), .9, .4));
  
  let ball2 = new Ball (new THREE.Vector3(-20,5,-5), new THREE.Vector3(4,0,5), ballMesh);

	balls.push (ball2);
  ////////////////////
light = new THREE.PointLight( 0xffffff, 1);
light.position.set( 0, 0, 0 );
scene.add( light );

light2 = new THREE.PointLight( 0xffffff, 1);
light2.position.set( 0,0, 0 );
scene.add( light2 );
///////////////////////////////
  /////////////////////////////////////////
  var wall = new THREE.Mesh (new THREE.BoxGeometry(200,40, 20), new THREE.MeshBasicMaterial({color:"pink", transparent: true, opacity:0.4}));
  scene.add (wall);
  wall.position.set(0, 20, 90);
  var wall2 = new THREE.Mesh (new THREE.BoxGeometry(200,40, 20), new THREE.MeshBasicMaterial({color:"pink", transparent: true, opacity:0.4}));
  scene.add (wall2);
  wall2.position.set(0, 20, -90);
  var wall3 = new THREE.Mesh (new THREE.BoxGeometry(200,40, 20), new THREE.MeshBasicMaterial({color:"pink", transparent: true, opacity:0.4}));
  scene.add (wall3);
  wall3.position.set(-90, 20, 0);
  wall3.rotation.y = Math.PI/2*3;
  var wall4 = new THREE.Mesh (new THREE.BoxGeometry(200,40, 20), new THREE.MeshBasicMaterial({color:"pink", transparent: true, opacity:0.4}));
  scene.add (wall4);
  wall4.position.set(90, 20, 0);
  wall4.rotation.y = Math.PI/2*3;
  /*var ground = new THREE.Mesh (new THREE.BoxGeometry(125,10, 125), new THREE.MeshBasicMaterial({color:"gray"}));
  scene.add (ground);
  ground.position.set(0, 0, 0);
  ground.rotation.y = Math.PI/2*3;*/
  var floor = new THREE.Mesh (new THREE.PlaneGeometry(200,200), new THREE.MeshPhongMaterial());
  floor.rotation.x = -Math.PI/2;
  scene.add (floor);

  

  ////////////////////////////////////////////////////////
  
/////////////////////////////////////////////
  
}

var counter = 0;
function animate() {

  requestAnimationFrame(animate);
  render();
  var dt = 0.1;
  var s = -0.1;
    for (let i = 0; i < balls.length; i++){
      var absX = Math.abs(balls[0].pos.x-balls[1].pos.x);
      var absZ = Math.abs(balls[0].pos.z-balls[1].pos.z);
      var d = 2*R-absX;
      var s = Math.sqrt(absX*absX+absZ*absZ)-2*R;
      var one,two,angle1,angle2;
      
      
      //light1.color.copy (balls[0].mesh.material.color)
			light.position.copy (balls[0].pos);
      light.position.x += 0.1
      
			//light2.color.copy (balls[1].mesh.material.color);
      light2.position.copy (balls[1].pos);
    
      light2.position.x += 0.1;
      if( s <= 2*R+5){

        // var angle = Math.atan2(balls[0].vel.z, balls[1].vel.x);
        //var degrees = 180 * angle / Math.PI;
        //cos(angle) = dot(a,b)/(norm(a)*norm(b))
        //return (360 + Math.round(degrees)) % 360;
    
        
        var x1,y1,z1,x2,y2,z2;
        x1 = balls[0].vel.x;
        y1 = balls[0].vel.y;
        z1 = balls[0].vel.z;
        x2 = balls[1].vel.x;
        y2 = balls[1].vel.y;
        z2 = balls[1].vel.z;
        angle1 = (x1*z1+x2*z2)/Math.sqrt(x1*x1+z1*z1)*Math.sqrt(x2*x2+z2*z2);

				//console.log(angle1);
        balls[0].vel.x = balls[1].vel.x*-1;
        balls[0].vel.z = balls[1].vel.z *-1;
        balls[1].vel.x = balls[0].vel.x * 1* Math.cos(Math.PI-angle1);
        balls[1].vel.z = balls[0].vel.z * 1* Math.cos(Math.PI-angle1);
     
        //a
        //angle1 = balls[0].vel;
        //angle2 = balls[1].vel;
        //one = angle1.angleTo(angle2);  
        //two = angle2.angleTo(angle1);  
        //tan1 = Math.sin()
        //console.log(one,two);
        //balls[0].vel = balls[0].vel*one;
      }
      balls[i].update (dt);
    }
    
 
}

function render() {

  renderer.render(scene, camera);

}


</script>
</div>
</body>
</html>